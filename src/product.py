#!/usr/bin/env python3

import random
import pack
import sqlite3
import tools.inventoryManager as dbtools

#generic product class from which all specific products inherit
#not generic in that it is designed for yugioh and may accidentally be expecting data in a way that in incompatible with other tcg's.
class product:

    #The base product class takes a sqlite3.Row object and a sqlite3.Connection object. In order to check what constructor to call, the shop queries the database row for the product anyway, so we might as well just assume that we get handed a full row instead of getting it ourselves.
    #More work would be required to make products work without an inventory database and that work is not currently planned.
    def __init__(self, product_entry, con):
        self.con = con
        self.set_name = product_entry["set_name"] #This is a string that acts as a primary key for the set.
        self.set_code = product_entry["set_code"] #This is a string that is usually 4 alphanumeric characters that act as a semi-unique identifier for the product. Should always be unique for packs (Some sets do have prerelease promotions in the inventory but they are not saleable and should always be after the set and not come up.)
        self.category = product_entry["category"] #This is the field that was used to decide which constructor to use. It is retained here so the price can be checked.
        self.promos = dbtools.splitDatabaseField(product_entry["promos"]) #A list of lists containing one or more card pools to randomly pull from
        #A fixed list of cards in the set.
        self.card_list = dbtools.splitDatabaseField(product_entry["card_list"])[0]#For the sake of consistency, I used the splitDatabaseField function for the card list, but as far as I am aware, that should always be a single fixed list with no randomization so I just dereference to get the first entry of the list of lists and pass it in as a list.
        self.unrollPacks(dbtools.splitDatabaseField(product_entry["packs"])) #A list of lists of packs in the set. Takes the form of one or more lists of setcode,number pairs denoting how many of each pack to open.
        self.contents = [] #A list of cards pulled from the set organized as a list of lists containing rarity, cardname, and setcode (i.e. [['UR','White Dragon Wyverburster','BLHR'],['UR','Shadoll Squamata','BLHR']] Unfortunately, the card_list field does not have rarities encoded so the setcode will be prepended in place of a rarity. This field is intended for use by the database.
        self.contents_strings = [] #Packs have nicely formatted strings listing their contents already so they will be appended here alongside other fields to make a nice printable list.
        
    def open(self):
        self.contents = []
        self.contents_strings = [f"\nContents of {self.set_name}:\n"]
        pass
        
    #This is a developer/debug print command to dump the whole object.
    def printProduct(self):
        print("Dumping Product object for: " + self.set_name + "\n")
        print(self.set_code)
        print(self.category)
        print(self.promos)
        print(self.card_list)
        print(self.packs)
        print(self.contents)
        self.printContents()
    
    #Function to retrieve the database-ready list of cards in the product.
    def getContents(self):
        return self.contents
        
    #Function to retrieve the list of print strings representing contents
    def getPrintableContents(self):
        return self.contents_strings
        
    def printContents(self):
        for content in self.contents_strings:
            print(content)
            
    #Function that creates a pack object for each different pack given to the constructor and makes a list of pack object,num_packs
    #This is done to minimize the number of times the pack information is accessed (from disk for now but eventually from the database
    #Product contents are generated by reopening the pack object as many times as indicated in the list.
    def unrollPacks(self, packs):
        #We first have to account for the possibility of this being an object that does not have packs. We will always be handed a string that unpacks into a list of lists by the shop so this is an easy check.
        if(packs[0][0] == ""): #Empty first entry of first list indicates that there were no packs.
            self.packs = ""
        else:
            self.packs = []
            for p in packs:
                self.packs.append([pack.pack(p[0],self.con),int(p[1])])#0=setcode,1=quantity
        
    #Function that randomly samples promos and adds them to the contents
    #Promo rarity is not tracked in the database but in some instances can be predicted based on product type(like in special editions)
    #In cases where the rarity is not known, just pass in the setcode.
    def generatePromos(self, promo_rarity, randomly_pull = True):
        #Start by appending a header.
        self.contents_strings.append("Promos:\n")
    
        #If we are randomly pulling, iterate over each list in the list of promos and sample it
        if(randomly_pull):
            promo_list = []
            for pool in self.promos:
                promo_list.extend(random.sample(pool,1)) #random.sample returns a list so just extend this.
        else: #If we aren't randomizing, assume there is only one pool and set our promos to the whole list from the first entry.
            promo_list = self.promos[0]
                
        for promo in promo_list:
            self.contents.append((promo_rarity, promo, self.set_code)) #Add database friendly entry
            self.contents_strings.append(promo_rarity.ljust(5) + promo + "\n")
            
        #Append an extra newline for prettiness
        self.contents_strings.append("\n")
        
    #Function that iterates over the list of pack objects and opens them the indicated number of times.
    #This function assumes that the contents fields have been cleared appropriately and that there are actually packs to open.
    def openPacks(self):        
        for p in self.packs:#p[0]=pack_object,p[1]=quantity
            for i in range(p[1]):
                p[0].open() #Regenerate contents
                self.contents.extend(p[0].getPulls()) #Retrieve the database formatted list from the pack and extend the product list.
                self.contents_strings.append(p[0].getPackString()) #Retrieve the single pack string and add it to the end of the contents_strings list.
    
#A Fixed Set expects to only have a card_list.
class fixedSet(product):
    def __init__(self, product_entry, con):
        product.__init__(self, product_entry, con)
        #In a fixedSet, the contents always equal the card_list
        #Take the card list and reformat it to fit database and prints.
        self.contents_strings = [f"\nContents of {product_entry['set_name']}:\n"]
        for card in self.card_list:
            self.contents.append((self.set_code,card,self.set_code)) #rarity,card,set_code format using set_code for unknown fixed set rarity.
            self.contents_strings.append(f"{card}\n")
    def open(self):
        #Do nothing
        pass
    
#A Box expects to find 0 or fixed promos and some number of packs, possibly from different sets.
class box(product):
    def open(self):
        product.open(self) #Call parent open function that clears contents.
        
        #Check if there are,
        if(self.promos[0][0] != ""):
            self.generatePromos(self.set_code,False) #Get the fixed list of promos and use the setcode as the rarity.
        
        self.openPacks()
                
#A Special Edition expects to find one or more lists of promos from which it picks one and some number of packs, possibly from different sets
class specialEdition(product):
    def open(self):
        product.open(self) #Call parent open function that clears contents.
    
        self.generatePromos("SR",True) #Randomly generate promos from one or more pools and assume they are Super Rare.
        self.openPacks()
        
#In order to have a unified product interface, this subclass of product is just a wrapper for the existing pack class from pack.py.
class individualPack(product):
    #All we need to do is make a single pack object using the setcode so we will override init to save some time and make a single pack.
    def __init__(self, product_entry, con):
        self.set_name = product_entry["set_name"]
        self.category = product_entry["category"]
        self.packs = pack.pack(product_entry["set_code"],con) #We just need a single pack.
    
    def open(self):
        product.open(self) #Call parent open function that clears contents.
        #Packs is actually just one pack.
        self.packs.open()
        self.contents = self.packs.getPulls()
        self.contents_strings.append(self.packs.getPackString())

# A fixed set is a product that is just a setlist with no variability
def isFixedSet(category):
    if(category == "Fixed Box" or category == "Deck" or category == "Legendary Decks"):
        return True
    else:
        return False
        
# A Box is a product with some number of packs and fixed or no promos.
def isBox(category):
    if(category == "Box" or category == "Tin" or category == "Premium Gold" or category == "Ultra Starter"):
        return True
    else:
        return False

# A Special Edition is a product with some number of packs and random promos
def isSpecialEdition(category):
    if(category == "Special Edition" or category == "Legacy Special Edition" or category == "Legendary Duelist Box"):
        return True
    else:
        return False
        
#Just a single pack object.
def isPack(category):
    if(category == "Current Pack" or category == "Legacy Pack" or category == "Legendary Duelist Pack" or category == "Battle Pack" or category == "ots"):
        return True
    else:
        return False
        